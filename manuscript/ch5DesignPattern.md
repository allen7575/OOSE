# 設計樣式

## I. 什麼是設計樣式

### 緣起

軟體的複雜度一直是軟體工程極力想解決的的問題。在傳統的程序導向系統中，軟體的複雜度是透過程序抽象(procedure abstraction)的方式來解決的，也就是說，將系統作功能性的切割，分成較小、容易處理的的單位；然而，程序性抽象的重用性(reusability)較差，較難以設計出高彈性(flexible)的系統。物件導向的設計概念以資料抽象(data abstraction)的方式來降低軟體的複雜度，可以開發出較有彈性、重用性較高的軟體系統。

然而，正如Gamma所言，開發物件導向的程式並非易事，要開發出高重用性的軟體更是困難。因此，Gamma等人提出以設計樣式(design pattern)的方法來輔助物件導向軟體的開發。設計樣式是將過去有經驗的程式設計者的設計經驗抽鍊、整理、包裝成特定的框架，用以解決系統設計上的特定問題，例如擴展性問題、維護性問題與重用性問題等。設計樣式的優點可綜合如下：

- 充分發揮物件導向的特性。物件導向為程式語言帶來極大的好處，可是由於其技術瓶頸並不低，許多人仍用物件導向的程式語言寫傳統的程序化方法。設計樣式大量的使用繼承、委託、多型、介面、抽象類別的概念，讓程式設計師可以透過設計樣式更了解物件的技術。
- 發揮知識管理的精神。設計樣式是一種程式設計師的知識管理，他們將特別的設計問題用一種較為抽象、可套用的方式呈現，以便後者可以引用、解決相類似的問題。將程式設計經驗抽離成設計樣式的過程就是一種將知識由內潛轉為外顯的動作。

- 為高品質的軟體提供一個機會。軟體品質從1960年提出軟體危機後受到極度的重視，不斷的研究投入到這個領域。設計樣式所提倡的概念即是高品質的軟體，它重視非功能需求，例如高維護性、高重用性、高模組化、高擴充性、高移植性等，並且為這些品質要求提供解決方案，讓程式設計師有依循的管道。

設計樣式起源於 Christopher Alexander，他發現建築時所遭遇的問題常常是不斷重複發生的，於是他將建築時候常遇見的這幾種問題分別搭配適合的解決方式，建立出一個良好的問題解決範本。軟體工程便將這樣的概念應用在軟體設計的問題上，用以解決經常發生的困難問題上。設計樣式在軟體工程界真正的流行是在Gamma等四人(有人稱之為四人幫(Gang of Four；GoF))合著的 Design Patterns一書發表後。書中將設計軟體時候常見的幾種問題抽離成23種設計樣式，實際的說明如何應用這些樣式解決物件設計上的問題，或是應用這些樣式建立高品質的軟體。因為這本書，物件的技術得以更精緻化，樣式的觀念也隨之風行。也由於這23個樣式受到普遍的採用，許多人便將這些樣式冠稱為GoF設計樣式。

### 設計樣式

樣式可簡易定義如下：

> *A solution to a problem in a context*


在某個情境下針對特定問題所提出的解決方案

### 設計樣式結構

一般而言，每個設計樣式都會透過一個結構性的描述來描述它的使用情境、欲解決的問題及解決的方法。每個樣式包含下列四項元素：

- 樣式名稱：用簡單易懂的命名來定義一個樣式，方便之後的溝通和使用。
- 問題描述：紀錄這個樣式所解決的問題和所面對的問題背景環境。這個部份將會描述樣式的情境與問題。
- 解決方式：詳細描述這個樣式內所使用到的技巧和元素，包含技術方法、元素結構及元素間的互動等。這個部份將會描述樣式的解決。
- 影響：使用這個樣式後可能可以推論的相關問題解決，使用後的好處壞處等，提供後來使用者可以有一個作出評估選擇的了解。

GoF設計樣式則擴充這四項，提供以下的項目以詳加說明樣式的使用：

- 目的(Intent)：該設計樣式所預期達到之目標。
- 動機(Motivation)：該設計樣式的背景資訊、使用動機。
- 應用時機(Applicability)：該設計樣式的適用時機、環境與限制。
- 物件結構(Structure)：該設計樣式之組成物件及他們之間的關係。通常採用UML中的類別圖來描述。
- 參與者(Participants)：物件結構中每一物件所擔負之責任說明。
- 合作方式(Collaborations)：物件間相互合作之方法。通常採用UML中的互動圖來描述。
- 範例程式(Sample code)：簡單卻充足的範例來呈現該設計樣式之實作。通常使用C++或Java。
- 結論(Consequence)：該設計樣式的有缺點。
- 引用範例和過程(Known uses)：別名。 
- 相關樣式(Related Patterns)：相關的樣式。 

### 知識管理

設計樣式的組成結構相當的符合知識管理架構。在know what方面，你必須先了解設計樣式可以解決什麼問題；你可以先翻看每一個樣式的使用目的、它的背景動機、它的使用時機等來分析有沒有樣式可以解決你的問題。在know what之後便是know how – 了解如何引用這個設計樣式來解決你的問題。設計樣式中所提供的物件結構、相關參與者、他們的合作方式可以作為你設計的參考，透過這三者將系統的設計圖描繪出一個大致上的形狀。如果你實在不知道如何將這些組成物件實作出來，你還可以使用『範例程式』來協助。最後，仔細的研讀樣式使用上的優缺點來避免可能產生的問題。另外，樣式之間可能會有關係：例如複合樣式通常會與覆迴或拜訪者樣式合用；雛形樣式與抽象工廠功能類似，通常是兩者擇一採用。你可以在設計樣式的相關樣式一節中找到這個資訊。
## II. GoF 23 個設計樣式
表5.1列出了GoF的23個設計樣式的簡要說明，由於數量很多，本章僅就其中兩個設計樣式抽象工廠及轉換器做比較詳細的說明，如果讀者有興趣，可以找專門講解設計樣的書籍來閱讀。
表　設計樣式概述
| 樣式名稱| 	說明 |
|----| ----| |抽象工廠 (Abstract Factory) | 在不需要指定明確的類別下，提供一個介面以建立一群相關的物件。因此，當系統預建立新的一群物件時，不需要改變既有的程式碼，只需擴充原來的類別即可。||建築者(Builder) | 將一個複雜物件的建構與其表達分開，藉此，相同的建構程序可以用在不同的表達上，提供擴充上的彈性。||工廠方法 (Factory Method) | 定義一介面以生成物件，但將其生成延遲給子類別來作決定。||雛形(Prototype) | 當直接生成物件的成本過高時，利用複製現有雛型實例的方式建立物件，而非採用生成的方法。||單例(Singleton) | 確保一個類別只會生成單一的物件。||轉接器(Adaptor) | 在不修改既有介面的情況下將一介面轉成另一個介面，藉以整合不同的物件。||橋接 (Bridge) | 將介面與實作分離，藉以提供介面與實作組合的多樣性。| 複合 (Composite) | 將物件組合成樹狀的結構並同時具備部分-全部的包含關係。組合的結構讓客端的物件以相同的介面來看待個別物件與複合物件，藉此簡化客端物件與服務端物件的的耦合力。 || 裝飾品 (Decorator) | 動態的增加物件的功能。相對於用繼承的方式來擴充功能，裝飾品提供更彈性的方法來擴充物件的功能。 ||門戶 (Façade) | 為一個子系統內眾多的服務提供一個統一的介面，藉以降低子系統間的耦合力。 || 輕量 (Flyweight) | 使用分享的方式來協助有效的管理輕量級物件的資源。 || 代理人 (Proxy) | 為某一物件提供一個中介控制的介面，以過濾對該物件的存取。 ||責任鏈 (Chain of Responsibility) | 避免將一個要求的提出者與接受者直接連結以降低他們之間的耦合力。責任鏈允許多個物件處理一個相同的要求。要求會在責任鏈中傳遞直至真正可以處理該要求的物件。|| 命令 (Command) | 將物件的需求封裝為一個類別，藉此提供更彈性的操作。例如將請求作排隊處理(queue)及提供請求回覆(undo)的功能。 ||解析器 (Interpreter) | 針對一個語言，提供該語言文法的表達法，以便於解析該語言內的結構與子句。 ||覆迴 (Iterator) | 提供一個較安全的方式以循序性的存取複合物件的內容 – 存取者不會知曉複合物件的內部的細節。 ||調停者 (Mediator) | 將物件的互動封裝為一個物件，藉以降低這群務間之件的耦合力。 || 紀念品 (Memento) | 在不破壞封裝性的前提下，紀錄並外顯化物件的狀態，以便該物件在之後可以回覆該狀態。 || 觀察者 (Observer) | 當一群物件間有一對多的相依關係時，當被依者物件的資料改變時，會通知其他依靠者物件以作出回應。| 狀態 (State) | 將物件的狀態自物件本身獨立出來，以提高物件行為變化的彈性。 ||策略 (Strategy) | 將演算法自其使用者中獨立出來，藉此提高該演算法使用上的彈性。亦即，演算法的使用者可以在不修改自身程式的情況下更換演算法。 ||樣板方法 (Template Method) | 定義一個方法演算法的結構為若干個步驟的組合，但將每個步驟的真實演算法延遲到子類別定義，藉此提高演算法變化的彈性。 ||拜訪者 (Visitor) | 將方法自其會運作的物件中獨立出來，藉此，避免新增方法時對該物件結構作的改變。 |### 設計樣式的分類
> GoF設計樣式可以由兩個層面來剖析與分類：用途(purpose) 與範圍 (scope)。

從用途來看，設計樣式可以分為生成 (creational) 用途、結構 (structural) 用途與行為 (behavioral)用途；生成型的設計樣式抽象化生成的過程，結構型的樣式考慮類別和物件如何組成更大的結構，而行為型的樣式考慮物件間的責任分配以及互動的方式。從範圍來看，設計樣式可以分為類別範圍與物件範圍。類別型的樣式主要考慮以繼承的方式來組合物件或解決問題，而物件型的樣式則以組合(compostion)方式來組合物件或解決問題。

儘管如此，並不是表示物件型的樣式就不會用到繼承的技巧，事實上絕大部分的物件型樣式都是繼承與組合同時採用，只不過它們的重點在於組合，而非繼承。 下表為此分類下的設計樣式整理。
表 GoF 樣式的分類
| - | 類別 | 物件 | 
|----| ---- | ---- || 生成 | 將部分物件的生成延遲到子類別決定。**設計樣式**：抽象工廠  |	將部分物件的生成委託給其他物件生成。**設計樣式**：建築者、工廠方法、雛形、單例 |
| 結構 | 使用繼承來組合介面或是實作。**設計樣式**：轉接器 | 使用物件組合實現新的功能及彈性，使得 run-time時可以更改物件間的組合。**設計樣式**：橋接器、複合、裝飾、外觀、輕量化、代理人 || 行為 | 使用繼承來分配類別間的行為。 **設計樣式**：解譯、樣板方法 | 採用物件間的組合而非繼承，描述一群對等的物件如何協同合作以完成工作。**設計樣式**：責任鏈、命令、策略、訪問、覆迴、調停、紀念品、觀察者、狀態|


## III. 對軟體工程的協助
設計樣式主要解決的設計階段的問題。我們可以將設計階段的問題簡單的歸類如下幾點：- 基本問題：如何從分析階段成功的跨越到設計階段？亦即，如何精細化(refine)分析模組，使之符合設計上的考量？- 品質問題：如何滿足非功能性需求以提升軟體的品質？設計的問題沒有唯一與明確的解答，絕大部分的情況都必須視系統的特性而定。設計樣式，雖然不能解決所有的問題，但提供了絕佳的經驗分享與技巧指導。以下即針對上述三個問題來分析設計樣式的解決之道。

* 協助進入設計階段
* 協助解決非功能性需求
* 彈性化設計

### A. 協助進入設計階段物件導向方法論最困難的工作之一是『如何決定物件』。亦即，我們如何將客戶的需求轉化為一群物件？在分析階段大部分的建議多是建議從問題敘述中找出名詞與動詞，並以『將名詞視為一個物件或屬性，動詞視為一個方法或關聯』等方法作為初步的分析方法。到了設計階段，由於許多細部技術的問題必須考量，物件的定義變得更為複雜，幾乎沒有什麼規則可以依循。設計樣式在此扮演著一個經驗分享的角色，描述由分析階段進入到設計階段可會遇到的問題，及相關的解決方式。有一些設計活動是我們在設計階段必須要作的，用以解決基本的設計問題。例如系統分解(decomposition)、物件分配(object allocation)、存取控制(access control)、控制流程(control flow)、元件合成(component composition)等：
* **系統分解**：用來降低系統的複雜度。將一個系統分解成數個較簡單的部分，稱之為子系統(subsystem)，並將這些子系統製成一群各個相互合作的類別。設計樣式即可以幫助我們解決系統分解相關的問題，例如，當我們要將子系統與介面類別包裝起來時，外觀設計樣式(Façade)幫助我們降低其相依性。其他的架構性設計樣式(architectural pattern)，如MVC可以協助此設計活動。
* **物件分配**：用以將物件或子系統分散在不同的電腦上，以滿足高效能需求或是多個分散使用者間的相互聯繫。代理者設計樣式提供在本地端物件與遠端物件之間提供了一個代理者，所以適合用在此方面。例如，當一個物件為了提高設計的簡易度，一個物件必須存在於一個不同的位址，此時便可以應用遠端代理者(Remote proxy)來隱藏該物件；虛擬代理者(Virtual proxy)為了效能最佳化的要求而生成物件。* **存取控制**：用來提供一個更安全的多重使用者環境，我們在可在此活動中定義存取控制規則。保護代理者(Protection proxy)設計物件在代理者設計物件中扮演一個內部管理的角色來過濾出不適當的存取。
* **元件合成**：當遭遇到重複性循環的問題可以應用現成的元件以降低開發成本。商業現成的元件可以被選出、採納並與系統結合在一起。適應者設計樣式(Adapter)可以將介面轉換成元件與系統間的黏著劑。物件模組在整個軟體開發的流程中是不斷的精細化(refine)而成為一個真實可執行的系統的。對於沒有經驗的程式設計師而言，這樣的精細化是很困難的，需要一些建議與指引。下表列出部分的實例說明設計樣式如何輔助解決基本的設計問題：

表:　活動導向設計樣式分析部分實例
| 設計活動  | 設計樣式  | 說明     |
|---------------|----------------|----|
| 系統分解| 門戶 |透過封裝一個帶有統一介面的子系統，減少類別間的相依性  |
| - |   觀察者   | 減少資料物件以及邊界物件的相依性 || 物件定位 | 遠端代理者 | 提供一個代理人物件，以隱藏一個物件長駐在另一個不同位址的事實 |
|-| 虛擬代理者 | 一經要求便創造所需求的物件以最佳化效能 |
| 存取控制 | 保護代理者 | 引進一個過濾器物件，預防不適當的存取 
|-| 覆迴 | 預防對於複合物件不適當的存取 ||元件組合 | 轉接器| 引進一個類別當作擁有不同介面的元件間的黏著劑，而不是為了物件間的合作而更改它們的介面| 
### B. 協助解決非功能性需求
設計樣式可視為一種功能性需求(functional requirement; FR)的延伸，用以滿足非功能性的需求(Non-functional requirement; NFR)。換句話說，設計樣式除了提供基本的功能性需求外，它還同時滿足品質化、非功能性的需求。例如在觀察者設計樣式的目的描述如下：
> *Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically*
分析此意圖，我們可了解此設計樣式的目的是解決一個主體物件與其相關相依物件之間的溝通問題。在功能性方面，它要求主體物件在物件更改狀態時能夠通知所有相依物件；在非功能性方面，它要求主體物件要在不知道相依物件的型態下自動的通知這些相依物件。從需求的角度來說，此設計樣式同時具備一個功能性的意圖(FR-intent)與延伸的非功能性意圖(NFR-intent)。又例如Abstract Factory設計樣式意圖如下：> *Provide an interface for creating families of related or dependent object without specifying their concrete classes 
> (提供一個介面，用以創造相關或是相依物件的產品族，且不事先指定這些物件的具體類別)*
表　設計樣式協助達成非功能性需求

| 樣式| 	功能性	| 非功能性 |
|----- | --------------------| -----------------||抽象工廠	 | 客戶端物件一次建立、使用一些相關物件(產品) | 客戶端在不指定產品物件具體型態的情形下建立、使用產品物件，提高了可重用性 ||觀察者	| 當一個主題改變自己的狀態時，通知所有依靠它的物件 | 主題在不知道所有依靠它的物件的型態下，自動通知它們，因此提高了模組化 |
| 命令 | 系統支援可復原的工作	|較容易增加新的工作，因此提高了可擴充性 | 
|覆迴|客戶端物件瀏覽集合容器物件	|客戶端物件在不知道集合容器的內部結構下，能夠去瀏覽它的內容，因此提高了可維護性|
|策略 |系統使用一演算法解決一特定問題	|較容易使用新的演算法解決問題，因此提高了可擴充性|
從```[功能性、非功能性]```的角度來看，此設計樣式在功能上是希望客端物件可以建立(或使用)一群相關的物件；其延伸的非功能性需求則要求在『不知曉這一群相關物件真正的型態下建立或使用這些物件』，據以達成可重用性。依據這樣的觀察，我們將設計樣式重新分析，將樣式的意圖區分為功能性意圖與非功能性意圖，藉此突顯該設計樣式對非功能需求的延伸。功能性意圖描述一個樣式要做什麼，而非功能性意圖描述其對一些品質屬性(quality attribute)的要求，像可重用性(reusability)、可維護性(maintainability)及可擴充性(extensibility)。

下表為以此角度分析下的部分實例。
相對於功能性需求與非功能性需求，我們可以建立功能性結構與非功能性結構。圖 為抽象工廠的實例。我們可以將圖X(a) 視為一個比較差的結構（因為他只能解決功能性意圖），而圖X(b)是比較好的結構，因為他可以同時達到功能性與非功能性的意圖。 (a) FR-structure (b) NFR-structure抽象工廠的功能性結構與非功能性結構### C. 彈性化設計
軟體的『修改』的難免的。需求的修改也無可避免的會造成設計的修改，因此，如何將修改所帶來的災害降到最低是軟體開發很重要的一環。彈性化的設計可部分的解決此一問題。欲達到彈性化設計，首先必須先將系統可能變化的部分抽離出來(當然，這需要一些系統分析的活動)，接下來便考慮如何用一些好的技巧來處理這些經常會變動的部分，使我們能在變動程式最少的情況下滿足這些變動。設計樣式提供了若干的協助。如下表，當我們意識到日後物件的實作很可能變動時，可以採用橋接器來應用；若是物件的狀態種類在日後很可能變動則採用狀態設計樣式。
表 應用設計樣式來管理變動

| 樣式 | 變動(彈性)的部分 |
|---- | ---- | | 橋接 | 物件的實作 || 觀察者 | 依附於其他物件的物件數目 ||狀態 | 物件的狀態 | |策略 | 演算法| ||複合 | 物件的結構與複合關係 | |裝飾品 | 物件的功能 | |轉接器 | 物件的介面 | |抽象工廠 | 產品物件的家族 | |工廠方法 | 被生成物件的子類別 | |外觀 | 子系統的介面 | |輕量 | 物件的儲存成本 | |代理人 | 物件的存取方式、物件的定址方式 | |責任鏈 | 履行要求的物件 | |命令 | 要求被履行的時機與方法 | |覆迴 | 複合式物件內的元素被存取的方式 | ## IV. 樣式的選擇與採用
當我們遇到問題時，可以依照以下的步驟來選擇及採用設計樣式：1. 瀏覽樣式的目的：瀏覽並檢視設計樣式的『目的』，尋找可能的樣式以解決所遭遇的問題。樣式的目的只是概略性的描述，如果不確定該樣式是否可以真的可以應用，可以各進一步的參考它的『動機』、『應用時機』等。2. 建立候選樣式群：當我們找到可能解決問題的候選樣式後，可以透過樣式中的『相關樣式』找到其他可能的樣式，並因此列出一群候選樣式。3. 檢驗樣式物件結構：觀察候選樣式群中樣式的『結構』，尋找一個合適目前系統架構的樣式，亦即，該設計樣式的物件架構可以對應到目前系統的物件架構。樣式中『參與者』的敘述可以很快的協助你了解樣式的物件結構。如果物件結構所提供的訊息不夠，可以進一步的參考『物件合作』以了解這些物件間的行為關係。4. 參考實作：當決定採用哪個樣式後，便可以參照設計樣式中所提示的『範例程式碼』將程式應用到系統中。對於熟悉物件技巧及設計樣式的設計者而言，他可以依照這樣的程序很快的找到他要的樣式並將之應用在系統中。然而，對於剛學習設計樣式的設計者而言，這樣的程序可能還是不夠的。學習者必須事前研讀過一些設計樣式，並實際的操作過一些例子，才能在初看到設計樣式的目的及結構時有所領會。因此，讀者應將設計樣式視為一種學習物件技巧的工具，平時就需去研讀瞭解，若等到要用到才去尋找，很難很快的找到。
